/*
BSD 2-Clause License

Copyright (c) 2018, Santiago Gil
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.URI;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import static java.security.Signature.getInstance;

/**
 * Greeter RESTful API.
 * Santiago Gil - May 2018.
 * https://santi.cf
 */

public class GreeterBackend {
    public static void main(String[] args) throws IOException {
        /**
         * Start a webserver and handle the /request endpoint.
         * By default it listens on port 8080, unless the `PORT`
         * environment varible is set.
         */

        int port = 8080;
        String env_port = System.getenv("PORT");
        if (env_port != null) {
            port = Integer.parseInt(env_port);
        }

        InetSocketAddress socket_address = new InetSocketAddress(port);

        HttpServer server = HttpServer.create(socket_address, 0);

        server.setExecutor(null);
        server.createContext("/greet", GreeterBackend::handle);
        server.start();
    }

    private static void handle(HttpExchange t) throws IOException {
        /**
         * Handler for the /greet endpoint.
         * It expects requests of the form `/greet?token=X`, where X is a 3 part field
         * composed of "username:timestamp:signature".
         */

        // Extracting the parameters from the request:
        URI request_uri = t.getRequestURI();

        Map<String, String> parameters;
        try {
            String token = extractTokenFromURI(request_uri);
            parameters = parseToken(token);
        } catch (Exception e) {
            httpReply("Bad request or Corrupt Token", t, 400);
            return;
        }

        String username = parameters.get("username");
        String timestamp = parameters.get("timestamp");
        String signature = parameters.get("signature");

        // First we check the signature:
        if (!isTokenAuthentic(username, timestamp, signature)) {
            httpReply("Token is not valid.", t, 403);
            return;
        }
        System.out.println("Signature valid");

        // The data seems to be genuine (generated by the webapp).

        // We now check if the token hasn't expired yet. If it hasn't, we return the greeting.
        if (!isTokenFresh(timestamp)) {
            httpReply("Token has expired.", t, 403);
        } else {
            httpReply(generateGreeting(username), t, 200);
        }

    }

    private static boolean isTokenAuthentic(String username, String timestamp, String signature) {
        /**
         * Check if the token is authentic by verifying that the signature
         * field corresponds to the value of "username:timestamp".
         */
        try {
            PublicKey key = webappPublicKey();

            // Building back the message ("username:timestamp")
            String message = String.format("%s:%s", username, timestamp);
            System.out.println(message);
            byte[] message_bytes = message.getBytes("utf-8");

            // Decoding the signature from base64:
            byte[] signature_bytes = Base64.getUrlDecoder().decode(signature);

            // And checking if it is a match:
            return isSignatureValid(message_bytes, signature_bytes, webappPublicKey());
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private static boolean isSignatureValid(byte[] message_bytes, byte[] signature_bytes,
                                            PublicKey public_key) {
        /**
         * Given a public key, a message and a signature as bytes, check whether
         * the signature validates the message.
         * We assume that the data comes signed with RSA, SHA256 and PKCS1v15 padding.
         */

        try {
            Signature signature = getInstance("SHA256withRSA");
            signature.initVerify(public_key);
            signature.update(message_bytes);

            boolean valid = signature.verify(signature_bytes);
            return valid;

        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    private static boolean isTokenFresh(String timestamp) {
        /**
         * Returns whether an authentic token is still unexpired.
         * (The token has 30 minutes to live since it was issued,
         * and the timestamp contained in the token is the issuance time.)
         */
        int token_issued = Integer.parseInt(timestamp);

        long now = Instant.now().getEpochSecond();

        // The token is valid for 30 minutes after being issued.
        return (now - token_issued < 30*60);
    }

    private static String generateGreeting(String username) {
        /**
         * Returns the personalized greeting for the given username.
         */
        return String.format("Stay hungry and foolish, %s.", username);
    }

    private static void httpReply(String message, HttpExchange t) throws  IOException {
        /**
         * Reply the given message with a status code of 200 - OK.
         */
        httpReply(message, t, 200);
    }

    private static void httpReply(String message, HttpExchange t, int status_code) throws IOException {
        /**
         * Send a reply containing the message as its body with the status code specified.
         */
        t.sendResponseHeaders(status_code, message.length());
        OutputStream os = t.getResponseBody();
        os.write(message.getBytes("UTF-8"));
        os.close();
    }

    private static String extractTokenFromURI(URI uri) throws IOException {
        /** Attempt to extract the value of the only parameter that should be
         * in the requested URL: `token`.
         */
        String query = uri.getRawQuery();
        System.out.println("query: " + query);

        if (!query.contains("token=")) {
            throw new RuntimeException();
        }

        return query.replace("token=", "");
    }

    private static Map<String, String> parseToken(String token) {
        /** Take the token, which is composed of `username:timestamp:signature`
         * and split its fields.
         * Returns a Map with those names as keys and String values.
         */
        String[] assigments = token.split(":"); // ["data=xyz", "signature=1234"]
        if (assigments.length != 3) {
            throw new RuntimeException();
        }

        Map<String, String> values = new HashMap<String, String>();
        values.put("username", assigments[0]);
        values.put("timestamp", assigments[1]);
        values.put("signature", assigments[2]);
        return values;
    }

    private static PublicKey webappPublicKey() throws Exception {
        /**
         * Loads the PEM-formatted public key that belongs to the webapp.
         * This will allow us to prove that the token was issued by the
         * webapp.
         */
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        String key_path = GreeterBackend.class.getResource("public.pem").getPath();

        byte[] key_bytes = loadPEM(key_path);

        KeyFactory factory = KeyFactory.getInstance("RSA");
        X509EncodedKeySpec spec = new X509EncodedKeySpec(key_bytes);

        PublicKey key = factory.generatePublic(spec);

        return key;
    }

    private static byte[] loadPEM(String path) throws IOException {
        /**
         * Helper that parses a PEM formatted key from a file.
         * It returns the decoded byte representation of the key.
         */
        // Based on https://stackoverflow.com/a/49753179
        File f = new File(path);
        InputStream in = new FileInputStream(f);

        String pem = new String(in.readAllBytes(), "utf-8");

        Pattern parse = Pattern.compile("(?m)(?s)^---*BEGIN.*---*$(.*)^---*END.*---*$.*");
        String encoded = parse.matcher(pem).replaceFirst("$1");
        return Base64.getMimeDecoder().decode(encoded);
    }
}